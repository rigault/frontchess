<!DOCTYPE html>
<html lang = "fr">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Chess</title>
   <link rel="icon" type="image/ico" href="favicon.ico">
   <link rel="stylesheet" type="text/css" href="chessdoc.css" />
</head>

<body>
<header>
Documentation sur le jeu d'echec, René Rigault, 2021
</header>
<h1>Sommaire </h1>
<ol>
<li><a href="#Introduction"> Introduction </a> </li>
<li><a href="#API"> API </a> </li>
<li><a href="#Serveur">Application côté serveur </a> </li>
<li><a href="#Client">Côté client</a> </li>
<li><a href="#Annexe">Annexe</a> </li>
</ol>

<div id = "main">

<h1 id="Introduction">1. Introduction </h1>
Ce jeu d'échec s'exécute sur un serveur. Il est écrit en langage C. Une API est publiée permettant à quiconque de développer la partie cliente indépendemment du serveur.
<p>
Côté client, un ensemble HTML5, CSS et JavaScript est proposé. Son rôle est de gérer l'affichage du jeu, de contrôler la saisie du joueur, de lancer vers le serveur la requête XMLHTTPRequest conforme à l'API.

<h1 id="API">2. API </h1>
Une API restful est définie et exposée par le serveur.
La requête est de type GET avec les paramètres apparents dans l'URL.
La réponse est au format JSON.
Le serveur ne gère pas d'état. Il répond aux requêtes sans utiliser d'informations en mémoires.
La requête contient un type, la totalité du jeu d'échecs au format ASCII FEN (Forsyth–Edwards Notation, voir Annexe), et un niveau de profondeur de jeu.

<h2>requêtes</h2>

Il y a trois éléments, tous optionnels, dans les requêtes.
En cas d'absence d'éléments, il existe des valeurs par défaut.
<p>

<table>
   <tbody><tr><th>Attribut</th><th>valeur</th><th>type</th></tr>
   <tr><td>reqType</td><td>0, 1, 2</td><td>int</td></tr>
   <tr><td>fen</td><td>chaine décrivant le jeu au format FEN</td><td>string</td></tr>
   <tr><td>level</td><td>niveau de profondeur demandé</td><td>int</td></tr>
   </tbody>
</table>

<h3>reqType </h3>

La valeur par défaut est 2 (si rien de spécifié dans la requête).

<ol start ="0">
   <li>requête de vérification d'accesibilité</li>
   <li>requête standard</li>
   <li>requete donnant des valeurs de variables internes au serveur</li>
</ol>

Une requête 2 est un sur-ensemble de la requête 1 qui est un sur-ensemble de la requête 0.

Sauf cas particulier, utiliser la requête 1.

<h3>fen </h3>

Le jeu dans les echanges externes (API) est représenté par la notation FEN (Forsyth–Edwards Notation). 
Le codage est le suivant :

<p>
<table>
   <tbody><tr><th>Pièce</th><th>Noirs</th><th>Blancs</th></tr>
   <tr><td>Pawn</td><td>p</td><td>P</td></tr>
   <tr><td>kNight</td><td>n</td><td>N</td></tr>
   <tr><td>Bishop</td><td>b</td><td>B</td></tr>         
   <tr><td>Rook</td><td>r</td><td>R</td></tr>      
   <tr><td>Queen</td><td>q</td><td>Q</td></tr>
   <tr><td>King</td><td>k</td><td>K</td></tr>
   </tbody>
</table>

<h3>level </h3>
Profondeur de la recherche demandée au serveur.
<p>
<h2>Exemple de requête complète</h2>
<pre>
http://&lt;server name&gt;/cgi-bin/chess.cgi?&amp;reqType=2&amp;level=3&amp;fen=rnbqkbnr/pppp1ppp8/4p3/8/8/PPPPPPPP/RNBQKBNR+b+KQkq
</pre>

Note : les espaces sont remplacés par des "+".

<h2> Réponses</h2>

Le format Jason est utilisé.
Les paires (attribut, valeur) sont les suivantes :
<p>
<table>
   <tbody><tr><th>Attribut</th><th>valeur</th><th>type</th></tr>
   <tr><td>description</td><td>Chess Rene Rigault 2019</td><td>string</td></tr>
   <tr><td>compilation-date</td><td>Dec  8 2020</td><td>string</td></tr>
   <tr><td>version</td><td>2.0</td><td>string</td></tr>
   <tr><td>clocktime</td><td>temps utilisation processeur en secondes</td><td>string</td></tr>
   <tr><td>time</td><td>temps de reponse serveur en secondes</td><td>float</td></tr>
   <tr><td>note</td><td>evaluation du jeu courant</td><td>int</td></tr>         
   <tr><td>eval</td><td>evaluation rendue par le minimax</td><td>int</td></tr> 
   <tr><td>computerStatus</td><td>Etat du roi ordinateur</td><td>int</td></tr>     
   <tr><td>playerStatus</td><td>Etat du Roi joueur</td><td>int</td></tr>
   <tr><td>fen</td><td>Jeu au format FEN</td><td>string</td></tr>
   <tr><td>lastTake</td><td>dernière prise ordi</td><td>char</td></tr>
   <tr><td>openingName</td><td>Nom de l'ouverture utilisée (si pertinent)</td><td>string</td></tr>
   <tr><td>endName</td><td>commentaires de fin de jeux avec dtz et wdl</td><td>string</td></tr>
   <tr><td>wdl</td><td>retour win-draw-loss des tables de fin de jeux syzygy</td><td>string</td></tr>
   <tr><td>computePlayC</td><td>deplacement ordinateur au format algébrique complet. ex: Pe2-e4</td><td>string</td></tr>
   <tr><td>computePlayA</td><td>deplacement ordinateur au format algébrique abrégé. ex: e4</td><td>string</td></tr>
   <tr><td>dump</td><td>dump de variables internes au serveur</td><td>string</td></tr>
   </tbody>
</table>

<h3>Réponse à une requete reqType=0</h3>
Seuls trois attributs sont présent : description, compilation-date et version.
<pre>
{
"description" : "Chess Rene Rigault 2020",
"compilation-date": "Dec  8 2020",
"version" : "2.1"
}
</pre>

<h3>Réponse à une requete reqType=1</h3>
<pre>

{
"description" : "Chess Rene Rigault 2020",
"compilation-date": "Dec 28 2020",
"version" : "2.1",
"clockTime": "0.000318",
"time" : "0.000550",
"note" : "71",
"eval" : "0",
"computerStatus" : "1",
"playerStatus" : "1",
"fen" : "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR+b+KQkq+-+0+0",
"lastTake" : " ",
"openingName" : "chess.w.fen D69; Queen's Gambit Declined, Orthodox Defense, Classical Variation; GameN: 1; TourN: 1;",
"endName" : "",
"wdl" : "9",
"computePlayC" : "Pc2-c4",
"computePlayA" : "c4",
}

</pre>

<h3>Réponse à une requete reqType=2</h3>
L'attribut dump est ajouté.
<pre>
{
"description" : "Chess Rene Rigault 2020",
"compilation-date": "Dec 28 2020",
"version" : "2.1",
"clockTime": "0.000318",
"time" : "0.000550",
"note" : "71",
"eval" : "0",
"computerStatus" : "1",
"playerStatus" : "1",
"fen" : "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR+b+KQkq+-+0+0",
"lastTake" : " ",
"openingName" : "chess.w.fen D69; Queen's Gambit Declined, Orthodox Defense, Classical Variation; GameN: 1; TourN: 1;",
"endName" : "",
"wdl" : "9",
"computePlayC" : "Pc2-c4",
"computePlayA" : "c4",
"dump" : "  maxDepth=4  nEvalCall=2  nLCKingInCheck=19  nBuildList=15  nValidComputerPos=22  nValidPlayerPos=20"
}

</pre>
<h1 id="Serveur">3. L'application côté serveur </h1>
<h2>Introduction </h2>
L'application est écrite uniquement en langage C et compatible cgi.
Elle est multiphread et tire partie des architectures à plusieurs coeurs afin de paralléliser la recherche.
Elle est basée sur la méthode du Minimax consistant à construire l'arbre des possibilités à une profondeur définie.
Au niveau de chaque feuille de l'arbre, la fonction d'évaluation est appelée. Elle se base sur quelques heuristiques et retourne une valeur qualifiant la position choisie. 
Afin de réduire la recherche aux seuls cas pertinents, la méthode Alpha-Bêta est utilisée.

<p>Conventions :
<ul>
   <li>Les blancs sont identifiés par des valeurs négatives et des caractères en majuscules,</li>
   <li>les noirs sont identifiés par des valeurs positive et des caractères en minuscules,</li>
   <li>les cases vides ont une valeur nulle (0),</li>
   <li>le jeu est représenté par un tableau de 64 octets,</li>
   <li>la liste des jeux est représentée par un tableau de jeux et un entier qui est l’index du prochain jeu à stocker,</li>
   <li>les lignes et colonnes d’une pièces sont représentées par un couple d'entiers (l, c) en interne,</li>
   <li>la notation algébrique complète est utilisée pour préciser les déplacements. </li>
</ul>

<h2>Structures de données essentielles</h2>
<ul>
   <li>Le jeu est représenté dans un tableau à 2 dimensions de type TGAME,</li>
   <li>une liste de jeux est un tableau de jeux. Type TLIST,</li>
   <li>nextL est un entier pointant sur le prochain jeux a insérer dans la liste,</li>
   <li>info est la structure rassemblant un ensemble de données de contrôles et d’état du jeux.</li>
</ul>

<h2>La recherche</h2>
La fonction buildList construit la liste de toutes les positions possibles jouables.
<p>La fonction find part du sommet de l’arbre (position courante du jeu) et appelle buildList.
<p> Quatrecomportements :

<ul>
   <li>Si niveau choisi -1, choix aléatoire,</li>
   <li>recherche dans la bibliothèque d'ouvertures,</li>
   <li>recherche dans le tables de fin de jeux,</li>
   <li>sinon pour toutes les positions possibles, génération d’un thread qui va lancer alphabeta,
récupération des évaluations dans le tableau tEval, puis choix au hasard d’un des jeux ayant obtenu la meilleure note.</li>
</ul>

La fonction alphabeta implémente l’algorithme Minimax avec élagage Alphabeta.

<h2>Le CLI Command Line Interface </h2>
<pre>
mode CLI sortie JSON : ./chess.cgi -i [&lt;jeuAuFormaFEN&gt;] [profondeur]
mode CLI sortie raw : ./chess.cgi -r [&lt;jeuAuFormaFEN&gt;] [profondeur]
mode CLI play : ./chess.cgi -p [&lt;jeuAuFormaFEN&gt;] [profondeur]
mode CLI : ./chess.cgi -t 
mode CLI help: ./chess.cgi -h 
</pre>

<h2>Les Threads</h2>
La recherche est multithread, permettant de multiplier la vitesse si le processeur est multicore.
La fonction "find" lance autant de thread qu’il y a de possibilité de jeux au sommet de l’arbre de recherche.
Un thread est donc associé au lancement de alphaBeta sur chaque fils de la racine de l’arbre.

<h2>Quelques astuces</h2>
Soit (l, c) une case et (lDest, cDest) une autre case.
<p>
Pour déterminer si un cavalier a le droit d’aller de (l, c) à  (lDest, cDest), il suffit que :
<pre>abs ((lDest-l) * (cDest-c)) == 2</pre>
<p>
Pour aller de la case (l, c) à la case (lDest, cDest), comme on ne peut qu’aller sur une case vide ou contenant une pièce adverse, la condition nécessaire suivante doit être satisfaite :
<pre>jeu [l][c] * jeu [lDest][cDest] &lt;= 0</pre>
Attention au cas du Roque.
<p>Pour vérifier qu’on est sur la même diagonale, la condition suivante doit être satisfaite:
<pre>abs (lDes-l) == abs (cDest-c)</pre>
<p>Un roi qui a le trait, qui est échec au roi et qui en se déplaçant sur toutes les cases jouable reste échec au roi est echec et mat.
<p>Un roi a le trait, qui n’est pas échec au roi et qui en se déplaçant sur toutes les cases jouable reste échec au roi est pat (en supposant bien sûr qu'il n'existe pas d'autres possibilités de jouer).
<h2>Un peu de théorie</h2>
<p>Soit n (resp. m) le nombre de coups possibles pour le joueur (resp. ordinateur).
<p>Soit p le nombre de coups à évaluer à l’avance. 2p est le nombre de demi-coups (joueur ou ordinateur).
<p>Soit MAX le nombre de combinaisons à ne pas dépasser (pour le temps) correspondant à un niveau donné.

<pre>nm puissance (2p) &lt; MAX 
2p &lt; log (MAX) / log (nm)
p &lt; log (MAX) / 2 log (nm)
</pre>

<h2>Optimisation de performances</h2>
<p>
Quelques particularitées liées au langage C, constatées avec le compilateur gcc sous Linux.
<p>
<pre>z = x * qui </pre> (avec qui = -1) est plus efficace que <pre>z = abs (x)</pre>
<p>Contrairement à ce qu’on pourrait croire faire 
<br>
<pre>if ((w = jeu [l][c]) == w1 || w == w2) return TRUE;
</pre>
est plus lent que :
<pre>
w = jeu [l][c];	
if (w == w1 || w == w2) return TRUE;
</pre>
<p>De même 
<pre>pt = &amp;jeu[0][0]
*(pt + 5*N + 7) = ROI;
</pre>
est plus lent que
<br>
<pre>jeu [5][7] = ROI;
</pre>

Comme indice de boucle, préférer le type "int" au type "char" car plus rapide.

<h2>Bibliothèque d'ouverture </h2>

Avant de lancer la recherche dans l'arbre, une bibliothèque d'ouverture est utilisée.
<p> Les fichiers utilisés sont placés dans un repertoire spécifique
<p> Il sont évalués dans l'ordre alphabétique. Ceci signifie que si deux configurations éligibles sont situées
dans des fichiers différent, seule celle appartenant au premier fichier dans l'orde alphabétique sera considérée. 
<p>Les fichiers suffixés par ".b.fen" et ".w.fen" sont au format textuel CSV et contiennent la liste des ouvertures au format FEN vus des noirs et vus des blancs.
<p> Format CSV : FENstring ; dep ; commentaires
<p> dep contient le déplacement en notation algébrique complète Xe2:e4[=Y] | O-O | O-O-O
<p> X : piece joue. Y : promotion,  O-O : petit roque,  O-O-O : grand roque
<p> Exemple
<pre>
rnbqkbnr/pppppppp8/8/4P3/8/PPPP1PPP/RNBQKBNR b Pe7-e5; Classique-Ouvert-ou-Alekhine-Coup1; RR
rnbqkbnr/pppppppp8/8/3P4/8/PPP1PPPP/RNBQKBNR b Pd7-d5; Classique-ferme-Coup1; RR
</pre>
<p> Les indications de couleurs b|w sont ignorées car l'ordinateur connait déja sa couleur et sélectionne le fichier ".b.fen" si noir, ".w.fen" si blanc en conséquence.

<h2>Gestion En Passant </h2>

La notion de En Passant est gérée dans l'API et dans la fonction différence qui sait reconnaître si la case "en passant" fournie par le joueur 
(epGamer) est utilisable pour une prise et si il est nécessaire de renseigner en passant par l'ordinateur (epComputer).
La fonction buildList a un complement pour énumérer les prises potentielles associées au "en passant". 
Par contre, l'arbre (au dessous du premier niveau) ne prend pas en compte les possibiités offertes par En Passant. Il est donc possible que la proposition faite soit sous optimale.  

<h2>Gestion des 50 coups </h2>

La notion des 50 coups est gérée dans l'API. Les 50 coups ont réinitialisés si un pion bouge ou si une pièces est prise.
C'est au logiciel client d'arrêter le jeu si les 50 coups sont atteints.
Les 50 coups ne dont pas gérés dans l'arborescence des jeux possibles. La proposition faite par l'ordinateur peux donc être sous optimale.
Les 50 coups sont en théorie gérée pour la fin de partie (Syzygy).

<h2>Fin de partie </h2>

La fonction syzygy renvoie la meilleure solution dès lors que le nombre de pièces restant sur le jeu est inférieur ou égal à 6.
Voir documentation sur les tables de fin de partie sur le Web.
La solution choisie est basée sur les tables syzygy stockées en local sur le serveur.
L'API donne un commentaire "endgame" incluant les valeur de :
<ul>
<li>WIN : 0-1 ou 1-0 ou 1/2-1/2 selon que le résultat attendu est victoire noire, blanche ou nulle.</li>
<li>WDL : valeur de 0 à 4</li>
<li>DTZ : distance to zero </li>
</ul>
Le meilleur mouvement ("bestmove") est sélectionné afin de minimiser DTZ. Le DTZ n'et pas la valeur minimale permettant d'atteindre le Mat mais la valeur jusqu'à prochaine remise à zéro du compteur des 50 coups 
(un pion bouge ou une pièce est prise). Le comportement de l'ordinateur est donc parfois surprenant, 
conduisant à des séquences longues. Mais il est efficace.

<h2>Gestion du CGI </h2>
<h3>Lire la requête GET </h3>
On utilise "getenv" avec "QUERY_STRING" en paramètre pour lire les paramètres de l'URL.
<pre>
 env = getenv ("QUERY_STRING"); // Les variables
   if (env == NULL) return 0;

   if ((ch = strstr (env, "fen=")) != NULL)
      sscanf (ch, "gen=%64s", getInfo.gameString);
   if ((ch = strstr (env, "level=")) != NULL)
      sscanf (ch, "level=%d", &amp;getInfo.level);
   if ((ch = strstr (env, "reqType=")) != NULL)
      sscanf (ch, "reqType=%d", &amp;getInfo.reqType);

</pre>

<h3>Envoi du jeu </h3>
Dans sendGame, on formate le JSON avec printf...
Ne pas oublier (très important) l'envoi de
<pre>Access-Control-Allow-Origin: *</pre>
Extrait de la fonction "SendGame" :
<pre>
   printf ("Access-Control-Allow-Origin: *\n");
   printf ("Content-Type: text/html\n\n");
   printf ("{\n");
   printf ("\"description\" : \"%s\",\n", DESCRIPTION);

</pre>

<h2>Aspects pratiques </h2>
<p>
Pour compiler, l'option pthread" est nécessaire pour la gestion multithread.
Il est possible de lancer chess en mode CLI (Command Line Interface) à partir de la console.
<br/>
<pre>
mode CLI (Interface API): sudo ./chess.cgi -i [&lt;jeuAFormatFEN&gt;] [profondeur]
mode CLI (Interface Raw): sudo ./chess.cgi -r [&lt;jeuAFormatFEN&gt;] [profondeur]
mode test : sudo ./chess -t
help : sudo ./chess.cgi -h
</pre>
Les pièces ordinateurs, noires sont positives en interne et représentées par des caractères minuscule pour l'API.
<br>
Les pièces joueurs, blanches, sont négatives en internes et représentées par des caractères majuscules pour l'API.
<p>

<table>
   <tr><th>Fichier côté serveur</th><th>dans ...cgi-bin</th><th>type</th></tr>
   <tr><td>chess.c, chessUtil.c, syzygy.c</td><td>code source</td><td>texte</td></tr>
   <tr><td>tbprobe.c, tbcore.c </td><td>code source pour l'access au tables de fin de jeux</td><td>texte</td></tr>
   <tr><td>chess.cgi</td><td>code exécutable</td><td>exec</td></tr>
   <tr><td>../repertoire ad-hoc/*.b.fen</td><td>bibliothèque d'ouvertures vue des noirs</td><td>texte</td></tr>
   <tr><td>../repertoire ad-hoc/*.w.fen </td><td>bibliothèque d'ouvertures vue des blancs</td><td>texte</td></tr>
   <tr><td>../autre repertoire ad-hoc/</td><td>repertoire contenant les tables de fin de jeux</td><td>texte</td></tr>
   <tr><td>chess.log</td><td>log</td><td>enregistre les requetes (dates, identification du type de poste)</td></tr>   
</table>
<p>

<h2>Les fonctions et les commentaires associés </h2>
<pre>

Fichier chess.c
---------------
/*   Pour produire la doc sur les fonctions : grep "\/\*" chess.c | sed 's/^\([a-zA-Z]\)/\n\1/' */
/*   Jeu d'echec */
/*   ./chess.cgi -i [FENGame] [profondeur] : CLI avec sortie JSON */
/*   ./chess.cgi -r [FENGame] [profondeur] : CLI avec sortie raw */
/*   ./chess.cgi -t : test unitaire */
/*   ./chess.cgi -p [FENGame] [profondeur] : play mode CLI */
/*   ./chess.cgi -h : help */
/*   autrement CGI */
/*   script CGI gérant une API restful (GET) avec les réponses au format JSON */
/*   fichiers associes : chess.log, chessB.fen, chessW.fen, chessUtil.c, syzygy.c, tbprobes.c tbcore.c et .h associes  */
/*   Structures de donnees essentielles */
/*     - jeu represente dans un table a 2 dimensions : TGAME sq64 */
/*     - liste de jeux qui est un tableau de jeux :  TLIST list */
/*     - nextL est un entier pointant sur le prochain jeux a inserer dans la liste */
/*   Noirs : 1 (Minuscules) */
/*   Blancs : -1 (Majuscules) */

int fMaxDepth (int lev, struct sinfo info) { /* */
   /* renvoie la profondeur du jeu en fonction du niveau choisi et */
   /* de l'etat du jeu */

bool LCkingInCheck (TGAME sq64, register int who, register int l, register int c) { /* */
   /* vrai si le roi situe case l, c est echec au roi */
   /* "who" est la couleur du roi qui est attaque */

bool fKingInCheck (TGAME sq64, int who) { /* */
   /* retourne vrai si le roi "who" est en echec */

bool kingCannotMove (TGAME sq64, register int who) { /* */
   /* vrai si le roi du joueur "who" ne peut plus bouger sans se mettre echec au roi */
   /* "who" est la couleur du roi qui est attaque */
   /* on essaye tous les jeux possibles. Si dans tous les cas on est echec au roi */
   /* c'est perdu. Noter que si le roi a le trait et qu'il n'est pas echec au roi il est Pat */
   /* si le roi est echec au roi il est mat */

int evaluation (TGAME sq64, register int who) { /* */
   /* fonction d'evaluation retournant MATE si Ordinateur gagne, */
   /* -MAT si joueur gagne, 0 si nul,... */

int alphaBeta (TGAME sq64, int who, int p, int refAlpha, int refBeta) { /* */
   /* le coeur du programme */

void *fThread (void *arg) { /* */
   /* association des thread a alphabeta */

void updateInfo (TGAME sq64) { /* */
   /* met a jour l'objet info a partir de l'objet jeu */

int find (TGAME sq64, TGAME bestSq64, int *bestNote, int color) { /* */
   /* ordinateur joue renvoie le meilleur jeu possible et le nombre de jeux possibles */

bool computerPlay (TGAME sq64, int color) { /* */
   /* prepare le lancement de la recherche avec find */

void cgi () { /* */
   /* MODE CGI

int main (int argc, char *argv[]) { /* */
   /* lit la ligne de commande */
   /* -i [FENGame] [profondeur] : CLI avec sortie JSON */
   /* -r [FENGame] [profondeur] : CLI avec sortie raw */
   /* -p [FENGame] [profondeur] : play mode CLI */
   /* -t : test unitaire */
   /* -h : help */
   /* autrement CGI */


Fichier syzygy.c
----------------
/* inspire de Fathom, adapte par RENE RIGAULT */

static bool parseFEN (struct pos *pos, const char *fen) { /* */
   /* traduit la chaine fau format FEN en une structure pos */
   /* ATTENTION CASTLING NE MARCHE PAS */

static void moveToStr (const struct pos *pos, unsigned move, char *str) { /* */
   /* Converti un deplacement en une chaine str au format algebrique complet. Ex :  Pe2-e4 */

bool syzygyRR (const char* path, const char *fen, unsigned *wdl, char *bestMove, char *comment) { /* */
   /* recherche dans la tablebase sygyzy situee dans path le jeu decrit en notation */
   /* FEN par fen. Renvoie le deplacement au format algebrique complet dans bestMove */
   /* le commentaire contient ce deplacement et les valeur WIN WDL DTZ */
   /* vrai si trouve, faux si erreur */


Fichier chessUtil.c
-------------------

int charToInt (int c) { /* */
   /* traduit la piece au format RNBQR... en nombre entier */

void printGame (TGAME jeu, int eval) { /* */
   /* imprime le jeu a la conole pour Debug */

int fenToGame (char *fenComplete, TGAME sq64, char *ep, int *cpt50, int *nb) { /* */
   /* Forsyth–Edwards Notation */
   /* le jeu est recu sous la forme d'une chaine de caracteres du navigateur au format fen */
   /* fenToGame traduit cette chaine et renvoie l'objet jeu ainsi que la couleur */
   /* 3kq3/8/8/8/8/3K4/+w+-- */
   /* retour 1 si noir, -1 si blanc */
   /* le roque est contenu dans la valeur du roi : KING ou CASTLEKING */
   /* les valeurs : en passant, cpt 50 coups et nb de coups sont renvoyées */
   /* les separateurs acceptés entre les differents champs sont : + et Espace */ 

char *gameToFen (TGAME sq64, char *fen, int color, char sep, bool complete, char *ep, int cpt50, int nb) { /* */
   /* Forsyth–Edwards Notation */
   /* genere le jeu sous la forme d'une chaine de caracteres au format FEN */
   /* le separateur est donne en parametre : normalement soit espace soit "+" */
   /* si le boolean "complete" est vrai vrai alors on transmet le roque, la valeur en passant, */
   /* le compteur des 50 coups et le nb de coups */

void moveGame (TGAME sq64, int color, char *move) { /* */
   /* modifie jeu avec le deplacement move */
   /* move en notation algébique Pa2-a4 ou Pa2xc3 */
   /* liste les fichier du reperdoire dir contenant la chaine filter */
   /* fichier dans l'ordre alphabetique */
   /* donc nommer les fichier les plus prioritaires en debut d'alphabet */
   /* appelle opening sur les fichiers listes jusqu a trouver */
   /* renvoie vrai si gameFen est trouvee dans l'un des fichiers faux sinon */

bool opening (const char *fileName, char *gameFen, char *sComment, char *move) { /* */
   /* lit le fichier des ouvertures et produit le jeu final */
   /* ce fichier est au forma CSV : FENstring ; dep ; commentaire */
   /* dep contient le deplacement en notation algebrique complete Xe2:e4[Y] | O-O | O-O-O */
   /* X : piece joue. Y : promotion,  O-O : petit roque,  O-O-O : grand roque */
   /* renseihne la chaine move (deplacement choisi) et le commentaire associe */
   /* renvoie vrai si ouverture trouvee dans le fichier, faux sinon */

bool symetryV (TGAME sq64, int l1, int c1, int cDest) { /* */ 
   /* vraie si il y a une piece egale a l1, c1 dans le symetrique par rapport a la colonne cDest */

bool symetryH (TGAME sq64, int l1, int c1, int lDest) { /* */ 
   /* vraie si il y a une piece egale a l1, c1 dans le symetrique par rapport a la ligne lDest */

char *abbrev (TGAME sq64, char *complete, char *abbr) { /* */ 
   /* transforme la specif algebriqe complete en abregee */

char *enPassant (int color, char *complete, char *strEp) { /* */
   /* renvoie les coordonnees eventuelles de la case en passant au format e5 */
   /* sinon renvoie "-" */

char *difference (TGAME sq64_1, TGAME sq64_2, int color, char *prise, char *complete, char *abbr, char *epGamer, char *epComputer) { /* */
   /* color = 1 pour les noirs, - 1 pour les blancs */
   /* retrouve le coup joue par Ordi */
   /* traite le roque. En dehors de ce cas */
   /* traite le en passant suggere par le joueur */
   /* en dehors de ces deux cas suppose qu'il n'y a que deux cases differentes (l1,c1) (l2, c2) */
   /* renvoie la chaine decrivant la difference */
   /* qui represente le deplacement au format complet Pe2:e4 et au format abregé e4 */
   /* renvoie aussi prise est la valeur de la piece prise. ' ' si pas de prise */
   /* renvoie aussi epComputer - en passant - pour renseigner les coordonnees eventuelles de prise en passant (sinon : "-") */
   /* epGamer permet de prendre en compte l'indication du gamer pour une prise possible */

void sendGame (const char *fen, struct sinfo info, int reqType) { /* */
   /* envoie le jeu decrit par fen et info au format JSON */


Fichier buildlistsimple.c
-------------------------

inline char *pushList (TGAME refJeu, TLIST list, int nListe, char *pl, int l1, int c1, int l2, int c2, int u) { /* */
   /* pousse le jeu refJeu dans la liste avec les modifications specifiees */

int buildListEnPassant (TGAME refJeu, register int who, char *epGamer, TLIST list, int nextL) { /* */
   /* apporte le complement de positions a buildList prenant en compte en Passant suggere par le joueur */

int buildList (TGAME refJeu, register int who, TLIST list) { /* */
   /* construit la liste des jeux possibles a partir de jeu. */
   /* 'who' joue */

</pre>

<h1 id="Client">4. Côté client </h1>

Le front, côté client est composé d'un fichier HTML, un CSS et de fonctions écrites en Javascipt.
main () est la fonction appelée dans le code HTML.

Le code javascript contrôle que l'entrée du joueur est valide, envoie le jeu via une requete XMLhttp request au format décrit dans la section API, reçoit la réponse du serveur JSON. Il interprête l'attribut fen et affiche le jeu.

<h2>Aspects pratiques </h2>

<table>
   <tbody><tr><th>Fichier pour le client</th><th>Commentaire</th></tr>
   <tr><td>chess.html</td><td>HTML5</td></tr>
   <tr><td>chess.css</td><td>css</td></tr>
   <tr><td>chess.js</td><td>fonctions Javascript</td></tr>
   <tr><td>favicon.ico</td><td>icône</td></tr>
   <tr><td>beep.wav</td><td>son pour retour serveur</td></tr>   
   </tbody>
</table>

<h2>Les fonctions Javascript</h2>
<pre>

/* Code colonne au format a-h. c = 0, cToString = "a" */
function cToString (c)
  
/* renvoie l, c en fonction de la case en notation "e1" */
function stringToLC (str)
  
/* Forsyth–Edwards Notation */
/* genere le jeu sous la forme d'une chaine de caracteres au format FEN */
/* le separateur est : "+" */
/* le roque est indiqué ainsi que "en passant" */
/* le compteur des 50 coups et le nb de coups */
function gameToFen (jeu, color, ep, cpt50, noCoup)
  
/* Forsyth–Edwards Notation */
/* fenToGame traduit une chaine de caracteres au format FEN et renvoie l'objet jeu ainsi que la couleur */
/* 3kq3/8/8/8/8/3K4/+w+-- */
/* retourne le jeu et la valeur de la case "en passant" */
/* le roque est contenu dans la valeur du roi : KING ou CASTLEKING */
/* les separateurs acceptes entre les differents champs sont : + et Espace */ 
function fenToGame (fen, jeu)
  
/* vraie si il y a une piece egale a l1, c1 dans le symetrique par rapport a la colonne cDest */
function symetryV (sq64, l1, c1, cDest)
   
/* vraie si il y a une piece egale a l1, c1 dans le symetrique par rapport a la ligne lDest */
function symetryH (sq64, l1, c1, lDest)
   
/* transforme la specif algebriqe complete en abregee */
function abbrev (sq64, complete)
  
/* vrai si le roi situe case l, c est echec au roi */
/* "who" est la couleur du roi qui est attaque */
function LCkingInCheck (sq64, who, l, c)
  
/* verifie que le deplacement choisi est valide */
/* renvoie CASTLING_GAMER ou EN_PASSANT ou vrai ou faux */
function verification (jeu, l, c, lDest, cDest, who)
  
/* verifie que la case choisie par le joueur est valide */
/* il est nécessaire que la pièce puisse bouger d'au moins une case */
function choiceIsOK (jeu, l, c, who)
  
/* traduit des secondes au format HH:MM:SS */
function secToHHMMSS (sec)
  
/* affiche le chrono joueur */
function chronoGamer()
  
/* met a jour le niveau pour profondeur de la recherche */
function updateLevel ()
  
/* provoque une requete vers le serveur */
function pass ()
  
/* inverse l'affichage */
function reverseDisplay ()
  
/* fait passer du mode normal au mode test */
function reverseTest ()
  
/* va un coup en arrière */
function back ()
  
/* repart un coup en avant */
function forward ()
  
/* met à jour le jeu suite à saisie d'un chaîne FEN */
function refresh ()
  
/* affecte les blancs au joueur ou à l'ordinateur */
function whoGetWhites ()
  
/* retourne false si on arrete le jeu, TRUE si on continue */
/* affiche des infos fonction des codes reçus du serveur */
function statusAnalysis ()
  
/* saisie du deplacement par le joueur sans vérif pour test */
function test (nom)
  
/* saisie du deplacement par le joueur */
function moveRead (nom)
  
/* envoie requete asynchrone XMLHttpRequest au serveur */
function serverRequest ()
  
/* met a jour l'objet info a partir de l'objet jeu */
function infoUpdate (jeu)
  
/* met a jour la page */
function displayUpdate ()
  
/* partie commune dans Display */
function commonDisplay (l, c)
  
/* affiche l echiquier en page HTML */
function display ()
  
/* programme principal */
function main ()
  

</pre> 
<h2>Codage des pièces</h2>
<div id = "conteneur">
<div id="gauche">
<table>
   <tbody><tr><th>Pièce Joueur</th><th>Char</th><th>Interne</th><th>Unicode</th></tr>
   <tr><td>Void</td><td>-</td><td>0</td><td>-</td></tr>
   <tr><td>Prawn</td><td>p</td><td>-1</td><td>&#x265F;</td></tr>
   <tr><td>kNight</td><td>n</td><td>-2</td><td>&#x265E;</td></tr>
   <tr><td>Bishop</td><td>b</td><td>-3</td><td>&#x265D;</td></tr>         
   <tr><td>Rook</td><td>r</td><td>-4</td><td>&#x265C;</td></tr>      
   <tr><td>Queen</td><td>q</td><td>-5</td><td>&#x265C;</td></tr>
   <tr><td>King</td><td>k</td><td>-6</td><td>&#x265A;</td></tr>
   </tbody>
</table>
</div>
<div id="droite">
<table>
   <tbody><tr><th>Pièce Ordi</th><th>Char</th><th>Interne</th><th>Unicode</th></tr>
   <tr><td>Void</td><td>-</td><td>0</td><td>-</td></tr>
   <tr><td>Prawn</td><td>P</td><td>1</td><td>&#x265F;</td></tr>
   <tr><td>kNight</td><td>N</td><td>2</td><td>&#x265E;</td></tr>
   <tr><td>Bishop</td><td>B</td><td>3</td><td>&#x265D;</td></tr>         
   <tr><td>Rook</td><td>R</td><td>4</td><td>&#x265C;</td></tr>      
   <tr><td>Queen</td><td>Q</td><td>5</td><td>&#x265C;</td></tr>
   <tr><td>King</td><td>K</td><td>6</td><td>&#x265A;</td></tr>
   </tbody>
</table>
</div>
</div>
<h2>Codage des case</h2>

Soit une case xn au format a1.
<p>
La ligne de la case xn est : n-1
<p>
La colonne de la case xn = CodeAscii (x) - CodeAscii ('a').
<pre>
a1 : l = 0, c = 0
a2 : l = 1, c = 0
...
h7 : l = 6, c = 7
h8 : l = 7, c = 7
</pre>
<p></p>


<h1 id="Annexe">5. Annexe </h1>

<h2>Format FEN : Forsyth–Edwards Notation</h2>
Voir Wikipedia
<p>
Un enregistrement FEN définit une position particulière, il est écrit sur une seule ligne en utilisant seulement les caractères ASCII. 
L'extension du fichier est « .fen ».
<p>
Cette notation est en anglais, les pièces sont nommées rook (tour), knight (cavalier), bishop (fou), queen (dame), king (roi) et pawn (pion).
<p>
Un enregistrement contient 6 champs. Le séparateur est l'espace. 

Note : Le "+" est utilisé dans nos programmes, pour être compatible avec le passage par URL et en liggne de commande.

Les champs sont :

<ol>
<li>Position des pièces vue du côté des blancs. Chaque rangée est décrite de la rangée 8 à la rangée 1.
Dans chaque rangée, le contenu est décrit de la colonne a à la colonne h.
Les pièces blanches sont symbolisées par des lettres majuscules ("KQRBNP"), les noires par des minuscules ("kqrbnp"). Les cases vides successives sont notées par un nombre (de 1 à 8).
Une barre oblique « / » sépare les rangées;</li>

<li>Couleur devant jouer. « w » si blanc doit jouer, "b" si noir;</li>

<li> Roques possibles. Utiliser une combinaison de plusieurs lettres : "K" (les blancs peuvent du côté roi [petit roque]), 
« Q » (les blancs peuvent du côté dame [grand roque]), respectivement « k » et « q » pour les noirs. 
Si aucun roque possible : « - »;</li>

<li>Case d'une prise en passant possible en notation algébrique. Si un pion vient de se déplacer de 2 pas, c'est la position « derrière » le pion. Sinon inscrire « - »;</li>

<li> Demi-coups : le nombre de demi-coups depuis la dernière capture ou le dernier mouvement de pion. Cela permet de savoir si la partie est nulle selon la règle des 50 coups; </li>

<li> Coups : le nombre de coups complets. Il commence à 1 et est incrémenté de 1 après le coup des noirs. </li>
</ol>

<p>
En partant de la position initiale du jeu traditionnel :

<p> rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1

<p> Ceci est une figuration des 8 rangées de l'échiquier en commençant par le haut, séparées par des "/" :

<ul>
<li>Les pièces noires ("rnbqkbnr"),
<li>les pions noirs (« pppppppp"),
<li>4 rangées vides avec le chiffre 8 pour 8 cases vides ("8/8/8/8"),
<li>les pions blancs ("PPPPPPPP"),
<li>les pièces blanches ("RNBQKBNR").
</ul>

<p>
Suivi d'informations complémentaires :

<ul>
<li>Tour aux blancs ("w"),</li>
<li>roques possibles ("KQkq"),</li>
<li>case en passant ("-"),</li>
<li>nombre de demi coups pour règle des 50 coups : "0",</li>
<li>numéro du coup complet en cours : "1".</li>
</ul>


Après le coup 1. e4 :
<p>
rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1
<p>
e3 désigne la case "en passant".


<h2>Notation algébrique</h2>

Les 8 colonnes sont « numérotées » de gauche à droite par les lettres minuscules allant de "a" à "h" et les 8 rangées numérotées de "1" à "8".

Chaque case est alors désignée par l'intersection d'une lettre (pointant une colonne) et d'un chiffre (pointant une rangée). Par exemple, la toute première case en partant du bas, à gauche, se nomme a1. La seconde, en allant de la gauche vers la droite, se nomme alors b1, ainsi de suite. Et la dernière se nomme alors h8 (tout en haut à droite).

Par ce système, on peut ainsi désigner des colonnes (vertical) et des rangées (horizontal). La colonne "a" comporte alors toutes les cases se trouvant visées par la coordonnée a, à savoir a1, a2, a3, a4, a5, a6, a7 et a8. Et la 4e rangée comporte alors toutes les cases se trouvant visées par la coordonnées 4, à savoir a4, b4, c4, d4, e4, f4, g4 et h4.

Chaque joueur doit avoir à sa droite une case blanche (a8 et h1). C'est le repère généralement utilisé pour vérifier, avant d'entamer la partie, que l'échiquier est bien orienté.
<p>
Pour noter le coup d'un joueur, on indique la nature de la pièce (par son code ou rien pour le pion, voir plus haut), 
les coordonnées de la case de départ, le déplacement (« - ») ou la prise (« x »), 
les coordonnées de la case d'arrivée et la promotion éventuelle (« =Q », par exemple).
<pre>
Pe2-e4 : le pion, en e2 au départ, se déplace en e4 ;
Pe7-e8=C : le pion, en e7 au départ, se déplace en e8 et est promu en cavalier ;
Nf6xe4 : le cavalier, en f6 au départ, va sur la case e4 en prenant la pièce située sur cette case.
</pre>
Le numéro d'ordre des coups est donné pour les Blancs et n'est pas répété pour les Noirs dont le coup s'inscrit à la suite après une seule espace :
<pre>
1. Pe2-e4 Ng8-f6
2. Pd2-d4 Nf6xe4
</pre>

<h2>Notation algébrique abrégée</h2>

<p>
Lorsque la pièce jouée est un pion, on omet de noter l'initiale de la pièce (P).
<p>On ne mentionne pas la case de départ de la pièce lorsqu'il n'y a pas d'ambigüité ; en effet dans la majorité des cas, une seule pièce du type indiqué peut se rendre sur la case d'arrivée.
En cas d'ambiguïté sur la pièce qui se déplace, on marque la lettre de la colonne où se trouve la bonne pièce. 
<p>Exemple : un cavalier blanc en f3, un cavalier blanc en g4. Le cavalier en f3 se déplace en e5. Noter Ne5 est insuffisant, on note alors Nfe5.
<p> S'il y a encore ambiguïté, on remplace la lettre de la colonne par le numéro de la rangée. 
<p>Exemple: un cavalier blanc en f3 et un cavalier blanc en f7. Ne5 ou Nfe5 sont tous deux insuffisants pour identifier la pièce ; on doit noter N3e5.
<pre>
Exemple :

1. e4 Nf6
2. d4 Nxe4
</pre>

<h2> Les fichiers PGN (Portable Game notation)</h2>
<p> Voir Wikipédia.
<p>
Portable Game Notation (PGN) désigne un format standard de codage des parties d'échecs.
<p>
Il est principalement utilisé pour la retransmission des parties sur internet et dans les bases de données de parties. Il utilise la notation algébrique abrégée. La plupart des programmes d’échecs la reconnaissent. L’extension habituelle est .pgn
<p>
Le fichier PGN d’une partie d'échecs est composée de deux parties : la première est une liste d’en-têtes qui décrivent la date et le lieu de la rencontre, les noms des protagonistes, etc. La seconde est constituée des coups joués et d’éventuels commentaires et qui est ponctuée par le résultat.
<p>
Dans l'exemple suivant, seuls les sept en-têtes obligatoires sont présents. Ils sont séparés de la liste des coups joués par une ligne vide. Il n'y a aucun commentaire associé aux coups joués, et le résultat final termine la partie.

<pre>

[Event "F/S Return Match"]
[Site "Belgrade, Serbia JUG"]
[Date "1992.11.04"]
[Round "29"]
[White "Fischer, Robert J."]
[Black "Spassky, Boris V."]
[Result "1/2-1/2"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3
O-O 9. h3 Nb8 10. d4 Nbd7 11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15.
Nb1 h6 16. Bh4 c5 17. dxe5 Nxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21.
Nc4 Nxc4 22. Bxc4 Nb6 23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7
27. Qe3 Qg5 28. Qxg5 hxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33.
f3 Bc8 34. Kf2 Bf5 35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5
40. Rd6 Kc5 41. Ra6 Nf2 42. g4 Bd3 43. Re6 1/2-1/2
</pre>

<h2> ECO : Encyclopedia of Chess Openings </h2>

Voir Wikipedia.
<p>
L'Encyclopédie des ouvertures d'échecs (Encyclopaedia of Chess Openings, ECO) est une publication en cinq volumes de la maison d'édition serbe l'Informateur d'échecs qui reprend les principales ouvertures connues dans le jeu. Elle utilise un code de classification des ouvertures, appelé code ECO, qui a été repris par d'autres publications et fait aujourd'hui figure de standard international.
<p>
L'Encyclopédie classe les ouvertures en cinq grandes catégories désignées par une lettre (de A à E), et chacune de ces catégories est divisée en cent sous-catégories, numérotées de 00 à 99 : par exemple B01 contient les ouvertures qui commencent par 1. e4 d5 (la défense scandinave).

<p>Un code ECO est donc composé de la lettre A, B, C, D ou E suivi de deux chiffres, de 00 à 99.
<p> On trouve sur les Web les 500 fichiers ECO : A00.pgn à F99.pgn.

<h2> Programmes utilitaires </h2>
<h3> PGNtoFEN </h3>
Un programme écrit en c, PGNtoFEN permet de convertir des fichier PGN au format FEN, assimilable par le serveur qui les utilise pour la gestion des ouvertures.
<ul>
<li> ./PGNtoFEN [-f] [-p] sourceFile [destFile]</li>
<li>PGNtoFEN traduit un fichier nom au format PGN en deux fichier au format FEN si destFime est fourni</li> 
<li>nom.b.fen pour les noirs (black)</li>
<li>nom.w.fen pour les blancs (white)</li>
<li>-p : affiche le jeu a la console en format convivial</li>
<li>-f : notation algébrique abrégée en français (R = Roi...) </li>
</ul> 

<h3> uniqRR </h3>

uniqRR est un programme écrit en C qui élimine les lignes redondantes d'un fichier trié.
Deux lignes sont considérées équivalentes si le premier champ est identique.
Ce premier champ est délimite par le separateur SEP. En général ";".
<p>
appel : ./uniqRR fileName
<h3> findgame </h3>

findgame est un programme écrit en C qui trouve le nième jeu dans un fichier PGN.
<p>
Un fichier PGN comportant des milliers de parties, il est utile de pouvoir un sélectionner une.

appel : ./findgame fileName no */

<h3>makefen.sh</h3>

"makefen" est un script shell bash qui applique PGNtoFFEN à l'ensemble des fichiers PGN d'un répertoire, concatène les fichiers, les trie et applique UniqRR.
Le résultat est constitué de deux fichiers ".b.fen" et ".w.fen", synthèse des fichiers PGN, trié et sans redondances.
<p>
Il est notamment appliqué sur les 500 fichiers de la bibliothèque eco ("A00.pgn" à "F99.pgn") pour produire les fichiers b.fen et w.fen utilisés par le serveur 
dans la phase d'ouverture.

</div> <!-- "main"-->

</body>
</html>
